Комментарий к фидбеку по первой загрузке решения:

- Добавил детальное описание проекта по заданию 1, уровень 1

# Задание 1

## Уровень 1. Проектирование

Для начала опишем все части изначального проекта, который мы планируем разделить:

### Структура проекта

- Директории и файлы в проекте:
  - blocks: Содержит стили всех компонентов
  - components: Содержит js код всех компонентов
  - contexts: Содержит единый файл контекста
  - images: Содержит все изображения для фронтенда
  - utils: Содержит все функции хелперы
  - fonts: Содержит css стили от всех компонентов

### Компоненты и модули

- Базовые компоненты:
  - Card.js, Footer.js, Header.js, ImagePopup.js, InfoTooltip.js, Login.js, PopupWithForm.js, ProtectedRoute.js, Register.js - данные компоненты не имеют зависимых компонентов и могут быть легко отчуждаемы.
  - AddPlacePopup.js, EditAvatarPopup.js, EditProfilePopup.js - данные компоненты зависят от другого компонента PopupWithForm.js
-  Основной компонент:
   -  App.js: Данный компонент импортирует каждый базовый компонент.

### Маршрутизация

Маршрутизация осуществляется из основного компонента App.js и внедрена на уровне кода.


### Зависимости проекта

Все зависимости проекта используют библиотеки из экосистемы React (за исключением зависимостей тестирования и дев зависимостей).
Более того, отдельной библиотеки управления состоянием также не присутствует, так как состояние приложения контролируется функционалом библиотеки React методам UseState.

### Утилиты и вспомогательные функции

В коде присутствует два основных скрипта по утилитам:

- api.js: Вспомогательные функции ответственные за вызовы методов бекенда, импортируются в основном компоненте App.js
- auth.js: Вспомогательные функции по аутентифкации, импортируются также в основном компоненте App.js

### Стили и их организация

- Стили находятся в двух основных директориях:
  - blocks: Описывают стили каждого отдельного компонента
  - vendor: Описывают общие стили шрифтов приложения

## Краткий итог анализа приложения

- Большинство компонентов независимы друг от друга, а некоторые компоненты наследуют функциональность других через импортирование.
- Маршрутизация встроена непосредственно в основной компонент App.js, который управляет всем приложением. 
- Для управления состоянием используется библиотека React с использованием хуков useState.
- В проекте присутствуют две важные утилитарные функции: одна для работы с API, другая для аутентификации.
- Стилизация выполнена с помощью CSS, где стили компонентов хранятся отдельно от общих стилей шрифтов.

## Выбор фреймворка

При выборе между решениями Module Federation или Single SPA я ориентировался на их основные преимущества. 
Согласно теории урока Single SPA позволяет бесшовно поддерживать несколько фронтенд фреймворков, а Module Federation делает упор на поддержке разных версий библиотек. Так как фронтенд данного проекта написан на одном фрейворке, главные преимущества Single SPA не подойдут и будет более целесообразно использовать Module Federation фреймворк.

## Уровень 2. Планирование изменений

Далее описаны мои идеи о стратегии разделения приложения на микрофронты, на основе которых будет предложено решение уровня 2. Все выводы сделаны на основе анализа приложения в предыдущих шагах.

### Стратегия разбития на микрофронты

1. Вертикальная нарезка - подходит для выполнения сложных пользовательских интерфейсов, однако данное приложение не включает такие интерефейсы, поэтому данную стратегию не используем.

2. Автономность команд - подходит при использовании разного технологического стека, однако данное приложение использует только React,  поэтому данная стратегия также не подходит.

3. Изоляция - подходит при инкапсуляции модулей с всеми зависимостями в отдельные микрофронты, подходит для данного проекта вместе с использованием Module Federation фреймворка, который также позволяет запускать каждый микрофронт с разными зависимостями.

### Реализация интеграции микросервисов

- Build time - используется для интеграции на этапе сборки и объединяет все сервисы в один - нам не подходит так как мы придерживаемся метода изоляции, а в build time все зависимости будут объединяться в одну, что нам не подходит.

- Run time - используется на этапе работы приложения и позволяет независимо собирать разные микрофронты - нам подходит из-за стратегии изоляции, каждый микрофронт должен работать с своими зависимостями независимо.

### Управление связью между микрофронтендами

- Pub/Sub - данный метод маршрутизации оптимален при реализации real-time дашбордов, что не актуально в нашем случае.

- Библиотека глобального состояния - необходимо при тесной связанности микрофронтендов, однако в данном приложении наоборот планируется разделение на несвязанные микрофронтены при помощи изоляции - такой способ тоже не подходит.

- Взаимодействие на основе АПИ - на данный момент уже реализован бекенд общего АПИ, и поэтому его можно использовать для взаимодействия между микрофронтами.

### Итоговое решение

Разделение на микрофронты можно найти в директории [microfrontends](./microfrontends/)

1. Микрофронтенд с popups: Включает файл PopupWithForm и все файлы зависящие от него. 

2. Микрофронтенд auth: Включает все текущие и будущие зависимости связанные с логинов и регистрацией - включает файлы Register, Login, ProtectedRoute, InfoTooltip

3. Микрофронтенд layout: Включает все зависимости общей структуры приложения: Header, Footer, App, Card

К каждому блоку также прилагаются стили которые используются в нем.


# Задание 2

Схема draw.io c новой микросервисной архитектурой хранится в файле [architecture-task2.drawio](architecture-task2.drawio)

## Краткое описание компонентов

- Сервис управления торговыми площадками: Создание и редактирования торговых площадок
- Сервис аналитики: Сервис создания аналитических отчетов
- Сервис управления пользователями: Создание и редактирование пользователей
- Сервис управления аукционом: Создание и редактирования новых аукционов
- Сервис техподдержки: Создание и валидация новых технических обращений
- Сервис управления товарами: Создание и редактирование товаров
- Сервис управления услугами: Создание и редактирование услуг
- Сервис управления заказами: Создание и редактирование заказов
- Сервис платежей: Создание и оплата платежей
- Сервис Авторизации и Аутентификации: Авторизация и аутентифиакция всех запросов к остальным сервисам
- Сервис нотификаций: Нотификация о всех событиях создания/удаления различных объектов
- Сервис поиска: Поиск товаров и услуг